<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive 3D Earth</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            box-sizing: border-box;
            margin: 0;
            overflow: hidden;
            background: linear-gradient(135deg, #0c0c0c 0%, #1a1a2e 50%, #16213e 100%);
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
        }
        
        canvas {
            display: block;
            cursor: grab;
        }
        
        canvas:active {
            cursor: grabbing;
        }
        
        .info-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 20px;
            color: white;
            max-width: 300px;
            z-index: 100;
        }
        
        .weather-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 20px;
            color: white;
            max-width: 280px;
            z-index: 100;
        }
        
        .location-status {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 12px 16px;
            color: white;
            font-size: 14px;
            z-index: 100;
        }
        
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 18px;
            z-index: 100;
        }
        
        .spinner {
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top: 3px solid #ffffff;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .marker-pulse {
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.7; transform: scale(1.2); }
            100% { opacity: 1; transform: scale(1); }
        }
        
        .weather-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 8px 0;
            padding: 6px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .weather-item:last-child {
            border-bottom: none;
        }
        
        .temp-display {
            font-size: 2rem;
            font-weight: bold;
            color: #60a5fa;
        }
    </style>
</head>
<body>
    <div id="loading" class="loading">
        <div class="spinner"></div>
        <div>Loading Earth...</div>
    </div>
    
    <div class="info-panel">
        <h3 class="text-lg font-bold mb-3 text-blue-300">üåç Interactive Earth</h3>
        <p class="text-sm text-gray-300 mb-2">‚Ä¢ Move mouse to explore surface</p>
        <p class="text-sm text-gray-300 mb-2">‚Ä¢ Scroll to zoom in/out</p>
        <p class="text-sm text-gray-300 mb-2">‚Ä¢ Gold marker shows your location</p>
        <p class="text-sm text-gray-300 mb-2">‚Ä¢ Flashlight illuminates viewing area</p>
        <p class="text-sm text-gray-300">‚Ä¢ Day/night cycle matches local time</p>
        <div id="timeDisplay" class="mt-3 text-xs text-yellow-300 font-mono"></div>
    </div>
    
    <div id="weatherPanel" class="weather-panel" style="display: none;">
        <h3 class="text-lg font-bold mb-3 text-green-300">üå§Ô∏è Live Weather</h3>
        <div id="weatherContent">
            <div class="text-center mb-3">
                <div id="weatherIcon" class="text-3xl mb-2">üå§Ô∏è</div>
                <div id="temperature" class="temp-display">--¬∞</div>
                <div id="description" class="text-sm text-gray-300 capitalize">Loading...</div>
            </div>
            <div id="weatherDetails"></div>
            <div class="text-xs text-gray-400 mt-3" id="lastUpdated">Updating...</div>
        </div>
    </div>
    
    <div id="locationStatus" class="location-status">
        üìç Detecting location...
    </div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.min.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // Weather API configuration
        const WEATHER_API_KEY = 'demo'; // Using demo mode for this example
        let userLat, userLon;
        
        // Weather icons mapping
        const weatherIcons = {
            'clear sky': '‚òÄÔ∏è',
            'few clouds': 'üå§Ô∏è',
            'scattered clouds': '‚õÖ',
            'broken clouds': '‚òÅÔ∏è',
            'overcast clouds': '‚òÅÔ∏è',
            'shower rain': 'üå¶Ô∏è',
            'rain': 'üåßÔ∏è',
            'thunderstorm': '‚õàÔ∏è',
            'snow': '‚ùÑÔ∏è',
            'mist': 'üå´Ô∏è',
            'fog': 'üå´Ô∏è'
        };

        // Earth creation
        const textureLoader = new THREE.TextureLoader();
        let earth;
        let userMarker;
        
        // Load Earth texture
        textureLoader.load(
            'https://threejs.org/examples/textures/land_ocean_ice_cloud_2048.jpg',
            (texture) => {
                const geometry = new THREE.SphereGeometry(2, 64, 64);
                const material = new THREE.MeshPhongMaterial({ 
                    map: texture,
                    shininess: 30,
                    transparent: true,
                    opacity: 0.95
                });
                earth = new THREE.Mesh(geometry, material);
                earth.castShadow = true;
                earth.receiveShadow = true;
                scene.add(earth);
                
                // Hide loading screen
                document.getElementById('loading').style.display = 'none';
            },
            undefined,
            (error) => {
                console.error('Error loading Earth texture:', error);
                // Fallback: create Earth without texture
                const geometry = new THREE.SphereGeometry(2, 64, 64);
                const material = new THREE.MeshPhongMaterial({ 
                    color: 0x4a90e2,
                    shininess: 30
                });
                earth = new THREE.Mesh(geometry, material);
                scene.add(earth);
                document.getElementById('loading').style.display = 'none';
            }
        );

        // Enhanced lighting with day/night cycle
        const sunLight = new THREE.DirectionalLight(0xffffff, 1.2);
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.width = 2048;
        sunLight.shadow.mapSize.height = 2048;
        scene.add(sunLight);

        const ambientLight = new THREE.AmbientLight(0x404040, 0.2);
        scene.add(ambientLight);

        // Moon light for night time
        const moonLight = new THREE.DirectionalLight(0x9bb5ff, 0.3);
        scene.add(moonLight);

        // Add subtle rim lighting
        const rimLight = new THREE.DirectionalLight(0x4a90e2, 0.2);
        rimLight.position.set(-5, 0, -5);
        scene.add(rimLight);
        
        // Function to update lighting based on time
        function updateDayNightLighting() {
            const now = new Date();
            const hours = now.getHours();
            const minutes = now.getMinutes();
            const totalHours = hours + minutes / 60;
            
            // Calculate sun position based on time (sunrise ~6am, sunset ~6pm)
            const sunAngle = ((totalHours - 6) / 12) * Math.PI;
            const sunHeight = Math.sin(sunAngle);
            
            // Position sun light
            sunLight.position.set(
                Math.cos(sunAngle) * 8,
                sunHeight * 5,
                Math.sin(sunAngle) * 3
            );
            
            // Position moon light (opposite to sun)
            moonLight.position.set(
                -Math.cos(sunAngle) * 8,
                -sunHeight * 5,
                -Math.sin(sunAngle) * 3
            );
            
            // Adjust light intensities based on time of day
            if (totalHours >= 6 && totalHours <= 18) {
                // Daytime
                const dayIntensity = Math.max(0.3, sunHeight);
                sunLight.intensity = dayIntensity * 1.5;
                moonLight.intensity = 0.1;
                ambientLight.intensity = 0.3;
                
                // Warmer colors during sunrise/sunset
                if (totalHours < 8 || totalHours > 16) {
                    sunLight.color.setHex(0xffa500); // Orange
                    ambientLight.color.setHex(0x4a4a6a);
                } else {
                    sunLight.color.setHex(0xffffff); // White
                    ambientLight.color.setHex(0x404040);
                }
            } else {
                // Nighttime
                sunLight.intensity = 0.1;
                moonLight.intensity = 0.4;
                ambientLight.intensity = 0.15;
                ambientLight.color.setHex(0x2a2a4a); // Blue tint for night
            }
        }

        // Flashlight effect - spotlight that follows camera view
        const flashlight = new THREE.SpotLight(0xffffff, 2.5);
        flashlight.position.copy(camera.position);
        flashlight.target.position.set(0, 0, 0);
        flashlight.angle = Math.PI / 6; // 30 degree cone
        flashlight.penumbra = 0.3; // Soft edges
        flashlight.decay = 1;
        flashlight.distance = 10;
        flashlight.castShadow = true;
        flashlight.shadow.mapSize.width = 1024;
        flashlight.shadow.mapSize.height = 1024;
        scene.add(flashlight);
        scene.add(flashlight.target);

        // Surface highlight circle
        const highlightGeometry = new THREE.RingGeometry(0.3, 0.5, 32);
        const highlightMaterial = new THREE.MeshBasicMaterial({
            color: 0x00ffff,
            transparent: true,
            opacity: 0.4,
            side: THREE.DoubleSide
        });
        const surfaceHighlight = new THREE.Mesh(highlightGeometry, highlightMaterial);
        scene.add(surfaceHighlight);

        camera.position.z = 5;
        
        // Zoom controls
        let zoomLevel = 5;
        const minZoom = 2.5;
        const maxZoom = 15;
        
        // Mouse wheel zoom
        document.addEventListener('wheel', (event) => {
            event.preventDefault();
            const zoomSpeed = 0.5;
            
            if (event.deltaY > 0) {
                zoomLevel = Math.min(maxZoom, zoomLevel + zoomSpeed);
            } else {
                zoomLevel = Math.max(minZoom, zoomLevel - zoomSpeed);
            }
            
            camera.position.z = zoomLevel;
        });

        // Weather functions
        async function fetchWeatherData(lat, lon) {
            try {
                // Using a demo weather service - in production, you'd use a real API like OpenWeatherMap
                // For demo purposes, we'll simulate weather data based on location
                const demoWeatherData = generateDemoWeather(lat, lon);
                updateWeatherDisplay(demoWeatherData);
            } catch (error) {
                console.error('Weather fetch error:', error);
                showWeatherError();
            }
        }

        function generateDemoWeather(lat, lon) {
            // Generate realistic demo weather based on location and time
            const now = new Date();
            const hour = now.getHours();
            const season = Math.floor((now.getMonth() + 1) / 3);
            
            // Base temperature on latitude and season
            let baseTemp = 20 - Math.abs(lat) * 0.5;
            if (season === 0 || season === 3) baseTemp -= 10; // Winter
            if (season === 2) baseTemp += 10; // Summer
            
            // Add daily variation
            const dailyVariation = Math.sin((hour - 6) / 12 * Math.PI) * 8;
            const temperature = Math.round(baseTemp + dailyVariation + (Math.random() - 0.5) * 6);
            
            const conditions = ['clear sky', 'few clouds', 'scattered clouds', 'overcast clouds', 'rain'];
            const condition = conditions[Math.floor(Math.random() * conditions.length)];
            
            return {
                temperature,
                condition,
                humidity: Math.round(40 + Math.random() * 40),
                windSpeed: Math.round(Math.random() * 20),
                pressure: Math.round(1000 + Math.random() * 50),
                visibility: Math.round(5 + Math.random() * 15),
                location: `${lat.toFixed(1)}¬∞, ${lon.toFixed(1)}¬∞`
            };
        }

        function updateWeatherDisplay(data) {
            document.getElementById('weatherPanel').style.display = 'block';
            
            const icon = weatherIcons[data.condition] || 'üå§Ô∏è';
            document.getElementById('weatherIcon').textContent = icon;
            document.getElementById('temperature').textContent = `${data.temperature}¬∞C`;
            document.getElementById('description').textContent = data.condition;
            
            const detailsHTML = `
                <div class="weather-item">
                    <span>üíß Humidity</span>
                    <span>${data.humidity}%</span>
                </div>
                <div class="weather-item">
                    <span>üí® Wind</span>
                    <span>${data.windSpeed} km/h</span>
                </div>
                <div class="weather-item">
                    <span>üå°Ô∏è Pressure</span>
                    <span>${data.pressure} hPa</span>
                </div>
                <div class="weather-item">
                    <span>üëÅÔ∏è Visibility</span>
                    <span>${data.visibility} km</span>
                </div>
            `;
            
            document.getElementById('weatherDetails').innerHTML = detailsHTML;
            document.getElementById('lastUpdated').textContent = 
                `Updated: ${new Date().toLocaleTimeString()}`;
        }

        function showWeatherError() {
            document.getElementById('weatherPanel').style.display = 'block';
            document.getElementById('weatherContent').innerHTML = `
                <div class="text-center text-red-300">
                    <div class="text-2xl mb-2">‚ö†Ô∏è</div>
                    <div>Weather data unavailable</div>
                    <div class="text-xs text-gray-400 mt-2">Check connection</div>
                </div>
            `;
        }

        // User location marker
        function addLocationMarker(lat, lon) {
            // Remove existing marker
            if (userMarker) {
                scene.remove(userMarker);
            }

            // Store coordinates for weather
            userLat = lat;
            userLon = lon;
            
            // Fetch weather data
            fetchWeatherData(lat, lon);

            // Create enhanced glowing marker
            const markerGroup = new THREE.Group();
            
            // Main marker (larger and brighter)
            const markerGeometry = new THREE.SphereGeometry(0.12, 16, 16);
            const markerMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xff4444,
                transparent: true,
                opacity: 1.0
            });
            const marker = new THREE.Mesh(markerGeometry, markerMaterial);
            
            // Inner glow
            const innerGlowGeometry = new THREE.SphereGeometry(0.18, 16, 16);
            const innerGlowMaterial = new THREE.MeshBasicMaterial({
                color: 0xff6666,
                transparent: true,
                opacity: 0.6
            });
            const innerGlow = new THREE.Mesh(innerGlowGeometry, innerGlowMaterial);
            
            // Outer glow
            const outerGlowGeometry = new THREE.SphereGeometry(0.25, 16, 16);
            const outerGlowMaterial = new THREE.MeshBasicMaterial({
                color: 0xffaaaa,
                transparent: true,
                opacity: 0.3
            });
            const outerGlow = new THREE.Mesh(outerGlowGeometry, outerGlowMaterial);
            
            // Pulsing ring
            const ringGeometry = new THREE.RingGeometry(0.3, 0.35, 32);
            const ringMaterial = new THREE.MeshBasicMaterial({
                color: 0xff0000,
                transparent: true,
                opacity: 0.8,
                side: THREE.DoubleSide
            });
            const ring = new THREE.Mesh(ringGeometry, ringMaterial);
            
            markerGroup.add(marker);
            markerGroup.add(innerGlow);
            markerGroup.add(outerGlow);
            markerGroup.add(ring);

            // Convert coordinates to 3D position
            const radius = 2.05; // Slightly higher above Earth surface
            const phi = (90 - lat) * (Math.PI / 180);
            const theta = (lon + 180) * (Math.PI / 180);

            markerGroup.position.x = -(radius * Math.sin(phi) * Math.cos(theta));
            markerGroup.position.y = radius * Math.cos(phi);
            markerGroup.position.z = radius * Math.sin(phi) * Math.sin(theta);

            scene.add(markerGroup);
            userMarker = markerGroup;

            // Auto-rotate Earth to show user location
            rotateToLocation(lat, lon);

            // Update status with "Go to Location" button
            document.getElementById('locationStatus').innerHTML = 
                `üìç Your location: ${lat.toFixed(2)}¬∞, ${lon.toFixed(2)}¬∞<br>
                <button onclick="rotateToLocation(${lat}, ${lon})" 
                        style="background: #3b82f6; color: white; padding: 4px 8px; border: none; border-radius: 4px; margin-top: 4px; cursor: pointer; font-size: 12px;">
                    üéØ Center View
                </button>`;
        }

        // Function to rotate Earth to show specific location
        function rotateToLocation(lat, lon) {
            // Calculate target rotation to center the location
            const targetY = -(lon * Math.PI / 180);
            const targetX = -(lat * Math.PI / 180) * 0.5;
            
            // Smooth rotation animation
            const startRotationY = earth.rotation.y;
            const startRotationX = earth.rotation.x;
            const duration = 2000; // 2 seconds
            const startTime = Date.now();
            
            function animateRotation() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                // Easing function for smooth animation
                const easeProgress = 1 - Math.pow(1 - progress, 3);
                
                earth.rotation.y = startRotationY + (targetY - startRotationY) * easeProgress;
                earth.rotation.x = startRotationX + (targetX - startRotationX) * easeProgress;
                
                if (progress < 1) {
                    requestAnimationFrame(animateRotation);
                }
            }
            
            animateRotation();
        }

        // Geolocation
        if (navigator.geolocation) {
            navigator.geolocation.getCurrentPosition(
                (position) => {
                    const { latitude, longitude } = position.coords;
                    addLocationMarker(latitude, longitude);
                },
                (error) => {
                    console.warn('Geolocation error:', error.message);
                    document.getElementById('locationStatus').innerHTML = 
                        'üìç Location access denied';
                    // Show demo weather for a default location
                    fetchWeatherData(40.7128, -74.0060); // New York as fallback
                },
                {
                    enableHighAccuracy: true,
                    timeout: 10000,
                    maximumAge: 60000
                }
            );
        } else {
            document.getElementById('locationStatus').innerHTML = 
                'üìç Geolocation not supported';
            fetchWeatherData(40.7128, -74.0060); // New York as fallback
        }

        // Mouse interaction
        let mouseX = 0;
        let mouseY = 0;
        let targetRotationX = 0;
        let targetRotationY = 0;

        document.addEventListener('mousemove', (event) => {
            mouseX = (event.clientX / window.innerWidth - 0.5) * 2;
            mouseY = (event.clientY / window.innerHeight - 0.5) * 2;
            
            targetRotationX = mouseY * 0.3;
            targetRotationY = mouseX * 0.3;
        });

        // Get timezone-based rotation
        function getTimezoneRotation() {
            const now = new Date();
            const hours = now.getHours();
            const minutes = now.getMinutes();
            const seconds = now.getSeconds();
            
            // Calculate total time in seconds since midnight
            const totalSeconds = hours * 3600 + minutes * 60 + seconds;
            
            // Convert to rotation (24 hours = 2œÄ radians)
            const timeRotation = (totalSeconds / 86400) * Math.PI * 2;
            
            return timeRotation;
        }

        // Update weather periodically
        setInterval(() => {
            if (userLat && userLon) {
                fetchWeatherData(userLat, userLon);
            }
        }, 300000); // Update every 5 minutes

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            if (earth) {
                // Update day/night lighting
                updateDayNightLighting();
                
                // Smooth mouse interaction
                earth.rotation.x += (targetRotationX - earth.rotation.x) * 0.05;
                earth.rotation.y += (targetRotationY - earth.rotation.y) * 0.05;
                
                // Time-based rotation (Earth rotates based on local time)
                const baseRotation = getTimezoneRotation();
                earth.rotation.y = baseRotation + (targetRotationY * 0.3);
                
                // Update flashlight position to follow camera
                flashlight.position.copy(camera.position);
                
                // Calculate surface point where user is looking
                const raycaster = new THREE.Raycaster();
                const mouse = new THREE.Vector2(mouseX * 0.5, -mouseY * 0.5);
                raycaster.setFromCamera(mouse, camera);
                
                if (earth) {
                    const intersects = raycaster.intersectObject(earth);
                    if (intersects.length > 0) {
                        const intersectionPoint = intersects[0].point;
                        
                        // Position surface highlight at intersection point
                        surfaceHighlight.position.copy(intersectionPoint);
                        surfaceHighlight.lookAt(camera.position);
                        surfaceHighlight.visible = true;
                        
                        // Make flashlight target the intersection point
                        flashlight.target.position.copy(intersectionPoint);
                        
                        // Animate highlight
                        const time = Date.now() * 0.005;
                        surfaceHighlight.material.opacity = 0.3 + Math.sin(time) * 0.1;
                        surfaceHighlight.rotation.z += 0.02;
                    } else {
                        surfaceHighlight.visible = false;
                    }
                }
                
                // Update time display with day/night indicator
                const now = new Date();
                const timeString = now.toLocaleTimeString();
                const timezoneString = Intl.DateTimeFormat().resolvedOptions().timeZone;
                const hours = now.getHours();
                const dayNightIcon = (hours >= 6 && hours <= 18) ? '‚òÄÔ∏è' : 'üåô';
                
                document.getElementById('timeDisplay').innerHTML = 
                    `${dayNightIcon} ${timeString}<br>üìç ${timezoneString}`;
                
                // Animate marker glow and pulsing
                if (userMarker) {
                    const time = Date.now() * 0.003;
                    const fastTime = Date.now() * 0.008;
                    
                    // Animate all glow layers
                    userMarker.children[1].material.opacity = 0.4 + Math.sin(time) * 0.2; // Inner glow
                    userMarker.children[2].material.opacity = 0.2 + Math.sin(time * 0.8) * 0.1; // Outer glow
                    userMarker.children[3].material.opacity = 0.6 + Math.sin(fastTime) * 0.3; // Ring
                    
                    // Scale animations
                    userMarker.children[1].scale.setScalar(1 + Math.sin(time * 1.5) * 0.15);
                    userMarker.children[2].scale.setScalar(1 + Math.sin(time * 1.2) * 0.1);
                    userMarker.children[3].scale.setScalar(1 + Math.sin(fastTime * 2) * 0.2);
                    
                    // Rotate the ring
                    userMarker.children[3].rotation.z += 0.02;
                }
            }
            
            renderer.render(scene, camera);
        }
        animate();

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Add stars background
        function createStars() {
            const starsGeometry = new THREE.BufferGeometry();
            const starsMaterial = new THREE.PointsMaterial({ 
                color: 0xffffff, 
                size: 1,
                transparent: true,
                opacity: 0.8
            });

            const starsVertices = [];
            for (let i = 0; i < 1000; i++) {
                const x = (Math.random() - 0.5) * 2000;
                const y = (Math.random() - 0.5) * 2000;
                const z = (Math.random() - 0.5) * 2000;
                starsVertices.push(x, y, z);
            }

            starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starsVertices, 3));
            const stars = new THREE.Points(starsGeometry, starsMaterial);
            scene.add(stars);
        }
        createStars();
    </script>
<script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'9872b197d6d0fd81',t:'MTc1OTIyNDU0NC4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>
</html>
