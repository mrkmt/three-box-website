<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive 3D Earth</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            box-sizing: border-box;
            margin: 0;
            overflow: hidden;
            background: linear-gradient(135deg, #0c0c0c 0%, #1a1a2e 50%, #16213e 100%);
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
        }
        
        canvas {
            display: block;
            cursor: grab;
        }
        
        canvas:active {
            cursor: grabbing;
        }
        
        .info-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 20px;
            color: white;
            max-width: 300px;
            z-index: 100;
        }
        
        .weather-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 20px;
            color: white;
            max-width: 280px;
            z-index: 100;
        }
        
        .location-status {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 12px 16px;
            color: white;
            font-size: 14px;
            z-index: 100;
        }
        
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 18px;
            z-index: 100;
        }
        
        .spinner {
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top: 3px solid #ffffff;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }

        .spinner-sm {
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top: 2px solid #ff00ff;
            width: 16px;
            height: 16px;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .marker-pulse {
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.7; transform: scale(1.2); }
            100% { opacity: 1; transform: scale(1); }
        }
        
        .weather-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 8px 0;
            padding: 6px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .weather-item:last-child {
            border-bottom: none;
        }
        
        .temp-display {
            font-size: 2rem;
            font-weight: bold;
            color: #60a5fa;
        }
    </style>
</head>
<body>
    <div id="loading" class="loading">
        <div class="spinner"></div>
        <div>Loading Earth...</div>
    </div>
    
    <div class="info-panel">
        <h3 class="text-lg font-bold mb-3 text-blue-300">üåç Interactive Earth</h3>
        <p class="text-sm text-gray-300 mb-2">‚Ä¢ Move mouse to explore surface</p>
        <p class="text-sm text-gray-300 mb-2">‚Ä¢ Scroll to zoom in/out</p>
        <p class="text-sm text-gray-300 mb-2">‚Ä¢ Gold marker shows your location</p>
        <p class="text-sm text-gray-300 mb-2">‚Ä¢ Flashlight illuminates viewing area</p>
        <p class="text-sm text-gray-300">‚Ä¢ Day/night cycle matches local time</p>
        <div id="timeDisplay" class="mt-3 text-xs text-yellow-300 font-mono"></div>

        <!-- Gemini Location Insight Feature -->
        <div class="mt-5 pt-3 border-t border-gray-700">
            <h3 class="text-md font-bold mb-2 text-yellow-300 flex items-center">
                üí° Location Insight
                <div id="insightLoading" class="spinner-sm ml-2" style="display: none;"></div>
            </h3>
            <div id="insightContent" class="text-sm text-gray-400 italic">Tap the button to learn a unique fact about this spot on Earth!</div>
            <button id="getFactBtn" class="mt-3 w-full py-2 bg-yellow-600 hover:bg-yellow-500 rounded-lg transition duration-200 text-sm font-semibold flex items-center justify-center" onclick="generateLocationFact()">
                ‚ú® Get Geographical Fact
            </button>
        </div>
    </div>
    
    <div id="weatherPanel" class="weather-panel" style="display: none;">
        <h3 class="text-lg font-bold mb-3 text-green-300">üå§Ô∏è Live Weather</h3>
        <div id="weatherContent">
            <div class="text-center mb-3">
                <div id="weatherIcon" class="text-3xl mb-2">üå§Ô∏è</div>
                <div id="temperature" class="temp-display">--¬∞</div>
                <div id="description" class="text-sm text-gray-300 capitalize">Loading...</div>
            </div>
            <div id="weatherDetails"></div>
            <div class="text-xs text-gray-400 mt-3" id="lastUpdated">Updating...</div>
        </div>
        <!-- Gemini Text-to-Speech Feature -->
        <button id="speakWeatherBtn" class="mt-3 w-full py-2 bg-purple-700 hover:bg-purple-600 rounded-lg transition duration-200 text-sm font-semibold flex items-center justify-center disabled:opacity-50" onclick="speakWeatherSummary(event)" disabled>
            ‚ú® Speak Weather Summary
        </button>
    </div>
    
    <div id="locationStatus" class="location-status">
        üìç Detecting location...
    </div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.min.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // API Configuration
        // NOTE: If you enter an invalid or expired OpenWeatherMap key, it will automatically fall back to DEMO data.
        const WEATHER_CDD_KMT = '7ece1632f9b444dcbc595528253009'; 
        // NOTE: This must remain an empty string for the Canvas environment to inject the key for Gemini APIs.
        const GEMINI_BDD_KMT = 'AIzaSyAo77ADwnkSB3xodxRq494c3vghBO71wls'; 
        const GEMINI_API_URL_FLASH = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${GEMINI_BDD_KMT}`;
        const GEMINI_API_URL_TTS = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key=${GEMINI_BDD_KMT}`;
        
        let userLat, userLon;
        let lastWeatherData = null;

        // Utility functions for Gemini TTS
        function base64ToArrayBuffer(base64) {
            const binaryString = atob(base64);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            return bytes.buffer;
        }

        function pcmToWav(pcmData, sampleRate) {
            const numChannels = 1;
            const bitsPerSample = 16;
            const bytesPerSample = bitsPerSample / 8;
            const dataLength = pcmData.length * bytesPerSample;
            const buffer = new ArrayBuffer(44 + dataLength);
            const view = new DataView(buffer);

            let offset = 0;

            // RIFF header
            view.setUint32(offset, 0x52494646, false); offset += 4; // "RIFF"
            view.setUint32(offset, 36 + dataLength, true); offset += 4; // file length - 8
            view.setUint32(offset, 0x57415645, false); offset += 4; // "WAVE"

            // fmt chunk
            view.setUint32(offset, 0x666d7420, false); offset += 4; // "fmt "
            view.setUint32(offset, 16, true); offset += 4; // chunk size (16 for PCM)
            view.setUint16(offset, 1, true); offset += 2; // format code (1 for PCM)
            view.setUint16(offset, numChannels, true); offset += 2; // number of channels
            view.setUint32(offset, sampleRate, true); offset += 4; // sample rate
            view.setUint32(offset, sampleRate * numChannels * bytesPerSample, true); offset += 4; // byte rate
            view.setUint16(offset, numChannels * bytesPerSample, true); offset += 2; // block align
            view.setUint16(offset, bitsPerSample, true); offset += 2; // bits per sample

            // data chunk
            view.setUint32(offset, 0x64617461, false); offset += 4; // "data"
            view.setUint32(offset, dataLength, true); offset += 4; // data size

            // Write PCM data
            const pcm16 = new Int16Array(buffer, offset, pcmData.length);
            for (let i = 0; i < pcmData.length; i++) {
                pcm16[i] = pcmData[i];
            }

            return new Blob([buffer], { type: 'audio/wav' });
        }
        
        // Weather icons mapping
        const weatherIcons = {
            'clear sky': '‚òÄÔ∏è',
            'few clouds': 'üå§Ô∏è',
            'scattered clouds': '‚õÖ',
            'broken clouds': '‚òÅÔ∏è',
            'overcast clouds': '‚òÅÔ∏è',
            'shower rain': 'üå¶Ô∏è',
            'light rain': 'üå¶Ô∏è',
            'moderate rain': 'üåßÔ∏è',
            'heavy intensity rain': 'üåßÔ∏è',
            'rain': 'üåßÔ∏è',
            'thunderstorm': '‚õàÔ∏è',
            'snow': '‚ùÑÔ∏è',
            'mist': 'üå´Ô∏è',
            'fog': 'üå´Ô∏è'
        };

        // Earth creation
        const textureLoader = new THREE.TextureLoader();
        let earth;
        let userMarker;
        
        // Load Earth texture (loading omitted for brevity in thought, but included in the final code)
        textureLoader.load(
            'https://threejs.org/examples/textures/land_ocean_ice_cloud_2048.jpg',
            (texture) => {
                const geometry = new THREE.SphereGeometry(2, 64, 64);
                const material = new THREE.MeshPhongMaterial({ 
                    map: texture,
                    shininess: 30,
                    transparent: true,
                    opacity: 0.95
                });
                earth = new THREE.Mesh(geometry, material);
                earth.castShadow = true;
                earth.receiveShadow = true;
                scene.add(earth);
                document.getElementById('loading').style.display = 'none';
            },
            undefined,
            (error) => {
                console.error('Error loading Earth texture:', error);
                const geometry = new THREE.SphereGeometry(2, 64, 64);
                const material = new THREE.MeshPhongMaterial({ 
                    color: 0x4a90e2,
                    shininess: 30
                });
                earth = new THREE.Mesh(geometry, material);
                scene.add(earth);
                document.getElementById('loading').style.display = 'none';
            }
        );

        // Lighting and 3D object setup (omitted for brevity)
        const sunLight = new THREE.DirectionalLight(0xffffff, 1.2);
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.width = 2048;
        sunLight.shadow.mapSize.height = 2048;
        scene.add(sunLight);
        const ambientLight = new THREE.AmbientLight(0x404040, 0.2);
        scene.add(ambientLight);
        const moonLight = new THREE.DirectionalLight(0x9bb5ff, 0.3);
        scene.add(moonLight);
        const rimLight = new THREE.DirectionalLight(0x4a90e2, 0.2);
        rimLight.position.set(-5, 0, -5);
        scene.add(rimLight);
        const flashlight = new THREE.SpotLight(0xffffff, 2.5);
        flashlight.position.copy(camera.position);
        flashlight.target.position.set(0, 0, 0);
        flashlight.angle = Math.PI / 6;
        flashlight.penumbra = 0.3;
        flashlight.decay = 1;
        flashlight.distance = 10;
        flashlight.castShadow = true;
        flashlight.shadow.mapSize.width = 1024;
        flashlight.shadow.mapSize.height = 1024;
        scene.add(flashlight);
        scene.add(flashlight.target);
        const highlightGeometry = new THREE.RingGeometry(0.3, 0.5, 32);
        const highlightMaterial = new THREE.MeshBasicMaterial({
            color: 0x00ffff,
            transparent: true,
            opacity: 0.4,
            side: THREE.DoubleSide
        });
        const surfaceHighlight = new THREE.Mesh(highlightGeometry, highlightMaterial);
        scene.add(surfaceHighlight);
        camera.position.z = 5;
        let zoomLevel = 5;
        const minZoom = 2.5;
        const maxZoom = 15;
        document.addEventListener('wheel', (event) => {
            event.preventDefault();
            const zoomSpeed = 0.5;
            if (event.deltaY > 0) {
                zoomLevel = Math.min(maxZoom, zoomLevel + zoomSpeed);
            } else {
                zoomLevel = Math.max(minZoom, zoomLevel - zoomSpeed);
            }
            camera.position.z = zoomLevel;
        });

        // --- GEMINI API INTEGRATIONS ---

        async function makeGeminiApiCall(url, payload) {
            let response;
            let attempts = 0;
            const maxAttempts = 3;
            const baseDelay = 1000;

            while (attempts < maxAttempts) {
                try {
                    response = await fetch(url, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    // Handle rate limiting / transient errors with backoff
                    if (response.status === 429) { 
                        attempts++;
                        const delay = baseDelay * (2 ** attempts) + Math.random() * 1000;
                        await new Promise(resolve => setTimeout(resolve, delay));
                        continue; 
                    }

                    if (!response.ok) {
                         // Throw status error for permanent failures (like 403)
                        throw new Error(`API call failed with status: ${response.status}`);
                    }

                    return await response.json();
                } catch (error) {
                    // Log the error but re-throw to be caught by feature handlers
                    throw error;
                }
            }
            throw new Error("Gemini API failed after multiple retries.");
        }

        async function speakWeatherSummary(event) {
            if (!lastWeatherData) {
                showWeatherError('No Data', 'Weather data not loaded yet.');
                return;
            }
            const btn = event.target.closest('button');
            const originalText = btn.innerHTML;
            btn.innerHTML = 'üîä Generating Audio...';
            btn.disabled = true;

            try {
                const prompt = `Say in a clear, friendly voice: The current weather condition in ${lastWeatherData.location} is ${lastWeatherData.condition}. The temperature is ${lastWeatherData.temperature} degrees Celsius, with ${lastWeatherData.humidity} percent humidity, and a wind speed of ${lastWeatherData.windSpeed} kilometers per hour.`;

                const payload = {
                    contents: [{ parts: [{ text: prompt }] }],
                    generationConfig: {
                        responseModalities: ["AUDIO"],
                        speechConfig: {
                            voiceConfig: {
                                prebuiltVoiceConfig: { voiceName: "Achird" } // Friendly voice
                            }
                        }
                    },
                };
                
                const result = await makeGeminiApiCall(GEMINI_API_URL_TTS, payload);

                const part = result?.candidates?.[0]?.content?.parts?.[0];
                const audioData = part?.inlineData?.data;
                const mimeType = part?.inlineData?.mimeType;

                if (audioData && mimeType && mimeType.startsWith("audio/")) {
                    const sampleRateMatch = mimeType.match(/rate=(\d+)/);
                    const sampleRate = sampleRateMatch ? parseInt(sampleRateMatch[1], 10) : 16000;
                    
                    const pcmData = base64ToArrayBuffer(audioData);
                    const pcm16 = new Int16Array(pcmData);
                    const wavBlob = pcmToWav(pcm16, sampleRate);
                    const audioUrl = URL.createObjectURL(wavBlob);
                    
                    const audio = new Audio(audioUrl);
                    audio.play();

                    audio.onended = () => {
                        btn.innerHTML = originalText;
                        btn.disabled = false;
                    };
                } else {
                    throw new Error("Invalid audio response from API.");
                }

            } catch (error) {
                console.error('TTS Error:', error);
                btn.innerHTML = '‚ùå TTS Failed';
                setTimeout(() => {
                    btn.innerHTML = originalText;
                    btn.disabled = false;
                }, 3000);
            }
        }

        async function generateLocationFact() {
            if (!userLat || !userLon) {
                document.getElementById('insightContent').innerHTML = 'Please enable geolocation first.';
                return;
            }

            const factBtn = document.getElementById('getFactBtn');
            const loadingSpinner = document.getElementById('insightLoading');
            const contentDiv = document.getElementById('insightContent');
            const originalText = factBtn.innerHTML;

            factBtn.disabled = true;
            factBtn.innerHTML = 'Generating Fact...';
            loadingSpinner.style.display = 'inline-block';
            contentDiv.innerHTML = 'Searching the web for geographical details...';

            const userQuery = `Find a compelling and unique geographical or historical fact about the coordinates: Latitude ${userLat.toFixed(4)}, Longitude ${userLon.toFixed(4)}. Keep the response concise, under 40 words.`;
            
            const payload = {
                contents: [{ parts: [{ text: userQuery }] }],
                tools: [{ "google_search": {} }], // Enable Google Search grounding
            };

            try {
                const result = await makeGeminiApiCall(GEMINI_API_URL_FLASH, payload);
                const text = result?.candidates?.[0]?.content?.parts?.[0]?.text || "Could not find a unique fact for this location.";
                
                contentDiv.innerHTML = `<p class="text-white">${text}</p>`;

                const groundingMetadata = result?.candidates?.[0]?.groundingMetadata;
                if (groundingMetadata && groundingMetadata.groundingAttributions) {
                    const sources = groundingMetadata.groundingAttributions
                        .map(attr => attr.web?.title)
                        .filter(title => title);
                    
                    if (sources.length > 0) {
                        contentDiv.innerHTML += `<p class="text-xs text-blue-400 mt-2">Source: ${sources[0]}</p>`;
                    }
                }

            } catch (error) {
                console.error('Fact Generation Error:', error);
                contentDiv.innerHTML = '‚ö†Ô∏è Error fetching geographical insight.';
            } finally {
                factBtn.disabled = false;
                factBtn.innerHTML = originalText;
                loadingSpinner.style.display = 'none';
            }
        }


        // --- ORIGINAL WEATHER & GEOMETRY FUNCTIONS ---

        function generateDemoWeather(lat, lon) {
            const now = new Date();
            const hour = now.getHours();
            
            let baseTemp = 20 - Math.abs(lat) * 0.5;
            const dailyVariation = Math.sin((hour - 6) / 12 * Math.PI) * 8;
            const temperature = Math.round(baseTemp + dailyVariation + (Math.random() - 0.5) * 6);
            
            const conditions = ['clear sky', 'few clouds', 'scattered clouds', 'broken clouds', 'overcast clouds', 'rain', 'thunderstorm', 'snow', 'mist', 'fog'];
            const condition = conditions[Math.floor(Math.random() * conditions.length)];
            
            return {
                temperature,
                condition,
                humidity: Math.round(40 + Math.random() * 40),
                windSpeed: Math.round(Math.random() * 20),
                pressure: Math.round(1000 + Math.random() * 50),
                visibility: (5 + Math.random() * 15).toFixed(1),
                location: `Lat: ${lat.toFixed(2)}¬∞, Lon: ${lon.toFixed(2)}¬∞ (Demo)`
            };
        }

        async function fetchWeatherData(lat, lon) {
            document.getElementById('speakWeatherBtn').disabled = true;

            if (!WEATHER_CDD_KMT) {
                console.warn('Weather API key is missing. Using DEMO data.');
                const demoData = generateDemoWeather(lat, lon);
                updateWeatherDisplay(demoData);
                return;
            }

            const apiUrl = `https://api.openweathermap.org/data/2.5/weather?lat=${lat}&lon=${lon}&appid=${WEATHER_CDD_KMT}&units=metric`;

            try {
                const response = await fetch(apiUrl);
                
                // CRITICAL FIX: If API returns unauthorized (401) or forbidden (403), fall back to DEMO mode.
                if (response.status === 401 || response.status === 403) {
                    console.warn('Weather API key failed authorization. Falling back to DEMO data.');
                    const demoData = generateDemoWeather(lat, lon);
                    updateWeatherDisplay(demoData);
                    return;
                }

                if (!response.ok) {
                    throw new Error(`Weather API error: ${response.statusText}`);
                }
                const data = await response.json();
                
                const weatherData = {
                    temperature: Math.round(data.main.temp),
                    condition: data.weather[0] ? data.weather[0].description : 'N/A',
                    humidity: data.main.humidity,
                    windSpeed: Math.round(data.wind.speed * 3.6), 
                    pressure: data.main.pressure,
                    visibility: (data.visibility / 1000).toFixed(1), 
                    location: `${data.name}, ${data.sys.country}`
                };

                updateWeatherDisplay(weatherData);
            } catch (error) {
                console.error('Weather fetch error:', error);
                // On any other failure (e.g., network error), switch to demo as well.
                const demoData = generateDemoWeather(lat, lon);
                updateWeatherDisplay(demoData);
            }
        }

        function updateWeatherDisplay(data) {
            lastWeatherData = data; 
            document.getElementById('weatherPanel').style.display = 'block';
            document.getElementById('speakWeatherBtn').disabled = false;
            
            const icon = weatherIcons[data.condition] || 'üå§Ô∏è';
            document.getElementById('weatherIcon').textContent = icon;
            document.getElementById('temperature').textContent = `${data.temperature}¬∞C`;
            document.getElementById('description').textContent = data.condition;
            
            const detailsHTML = `
                <div class="weather-item">
                    <span>üíß Humidity</span>
                    <span>${data.humidity}%</span>
                </div>
                <div class="weather-item">
                    <span>üí® Wind</span>
                    <span>${data.windSpeed} km/h</span>
                </div>
                <div class="weather-item">
                    <span>üå°Ô∏è Pressure</span>
                    <span>${data.pressure} hPa</span>
                </div>
                <div class="weather-item">
                    <span>üëÅÔ∏è Visibility</span>
                    <span>${data.visibility} km</span>
                </div>
            `;
            
            document.getElementById('weatherDetails').innerHTML = detailsHTML;
            document.getElementById('lastUpdated').textContent = 
                `Updated: ${new Date().toLocaleTimeString()} for ${data.location}`;
        }

        function showWeatherError(title = 'Error', message = 'Check connection') {
            lastWeatherData = null;
            document.getElementById('weatherPanel').style.display = 'block';
            document.getElementById('speakWeatherBtn').disabled = true;
            document.getElementById('weatherContent').innerHTML = `
                <div class="text-center text-red-300">
                    <div class="text-2xl mb-2">‚ö†Ô∏è</div>
                    <div>${title}</div>
                    <div class="text-xs text-gray-400 mt-2">${message}</div>
                </div>
            `;
        }

        function addLocationMarker(lat, lon) {
            if (userMarker) {
                scene.remove(userMarker);
            }

            userLat = lat;
            userLon = lon;
            
            fetchWeatherData(lat, lon);
            
            const markerGroup = new THREE.Group();
            
            const markerGeometry = new THREE.SphereGeometry(0.12, 16, 16);
            const markerMaterial = new THREE.MeshBasicMaterial({ color: 0xffd700, transparent: true, opacity: 1.0 });
            const marker = new THREE.Mesh(markerGeometry, markerMaterial);
            
            const innerGlowGeometry = new THREE.SphereGeometry(0.18, 16, 16);
            const innerGlowMaterial = new THREE.MeshBasicMaterial({ color: 0xffe666, transparent: true, opacity: 0.6 });
            const innerGlow = new THREE.Mesh(innerGlowGeometry, innerGlowMaterial);
            
            const outerGlowGeometry = new THREE.SphereGeometry(0.25, 16, 16);
            const outerGlowMaterial = new THREE.MeshBasicMaterial({ color: 0xfff0aa, transparent: true, opacity: 0.3 });
            const outerGlow = new THREE.Mesh(outerGlowGeometry, outerGlowMaterial);
            
            const ringGeometry = new THREE.RingGeometry(0.3, 0.35, 32);
            const ringMaterial = new THREE.MeshBasicMaterial({ color: 0xffd700, transparent: true, opacity: 0.8, side: THREE.DoubleSide });
            const ring = new THREE.Mesh(ringGeometry, ringMaterial);
            
            markerGroup.add(marker);
            markerGroup.add(innerGlow);
            markerGroup.add(outerGlow);
            markerGroup.add(ring);

            const radius = 2.05; 
            const phi = (90 - lat) * (Math.PI / 180);
            const theta = (lon + 180) * (Math.PI / 180);

            markerGroup.position.x = -(radius * Math.sin(phi) * Math.cos(theta));
            markerGroup.position.y = radius * Math.cos(phi);
            markerGroup.position.z = radius * Math.sin(phi) * Math.sin(theta);

            scene.add(markerGroup);
            userMarker = markerGroup;

            rotateToLocation(lat, lon);

            document.getElementById('locationStatus').innerHTML = 
                `üìç Your location: ${lat.toFixed(2)}¬∞, ${lon.toFixed(2)}¬∞<br>
                <button onclick="rotateToLocation(${lat}, ${lon})" 
                        style="background: #3b82f6; color: white; padding: 4px 8px; border: none; border-radius: 4px; margin-top: 4px; cursor: pointer; font-size: 12px;">
                    üéØ Center View
                </button>`;
        }

        function rotateToLocation(lat, lon) {
            if (!earth) return;
            const targetY = -(lon * Math.PI / 180);
            const targetX = -(lat * Math.PI / 180) * 0.5;
            
            const startRotationY = earth.rotation.y;
            const startRotationX = earth.rotation.x;
            const duration = 2000;
            const startTime = Date.now();
            
            function animateRotation() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const easeProgress = 1 - Math.pow(1 - progress, 3);
                
                earth.rotation.y = startRotationY + (targetY - startRotationY) * easeProgress;
                earth.rotation.x = startRotationX + (targetX - startRotationX) * easeProgress;
                
                if (progress < 1) {
                    requestAnimationFrame(animateRotation);
                }
            }
            animateRotation();
        }

        // Geolocation
        if (navigator.geolocation) {
            navigator.geolocation.getCurrentPosition(
                (position) => {
                    const { latitude, longitude } = position.coords;
                    addLocationMarker(latitude, longitude);
                },
                (error) => {
                    console.warn('Geolocation error:', error.message);
                    document.getElementById('locationStatus').innerHTML = 
                        'üìç Location access denied (using fallback)';
                    fetchWeatherData(40.7128, -74.0060);
                },
                {
                    enableHighAccuracy: true,
                    timeout: 10000,
                    maximumAge: 60000
                }
            );
        } else {
            document.getElementById('locationStatus').innerHTML = 
                'üìç Geolocation not supported (using fallback)';
            fetchWeatherData(40.7128, -74.0060);
        }

        let mouseX = 0;
        let mouseY = 0;
        let targetRotationX = 0;
        let targetRotationY = 0;

        document.addEventListener('mousemove', (event) => {
            mouseX = (event.clientX / window.innerWidth - 0.5) * 2;
            mouseY = (event.clientY / window.innerHeight - 0.5) * 2;
            
            targetRotationX = mouseY * 0.3;
            targetRotationY = mouseX * 0.3;
        });

        function getTimezoneRotation() {
            const now = new Date();
            const hours = now.getHours();
            const minutes = now.getMinutes();
            const seconds = now.getSeconds();
            const totalSeconds = hours * 3600 + minutes * 60 + seconds;
            const timeRotation = (totalSeconds / 86400) * Math.PI * 2;
            return timeRotation;
        }

        setInterval(() => {
            if (userLat && userLon) {
                fetchWeatherData(userLat, userLon);
            }
        }, 300000); 

        function updateDayNightLighting() {
            const now = new Date();
            const hours = now.getHours();
            const minutes = now.getMinutes();
            const totalHours = hours + minutes / 60;
            const sunAngle = ((totalHours - 6) / 12) * Math.PI;
            const sunHeight = Math.sin(sunAngle);
            
            sunLight.position.set(Math.cos(sunAngle) * 8, sunHeight * 5, Math.sin(sunAngle) * 3);
            moonLight.position.set(-Math.cos(sunAngle) * 8, -sunHeight * 5, -Math.sin(sunAngle) * 3);
            
            if (totalHours >= 6 && totalHours <= 18) {
                const dayIntensity = Math.max(0.3, sunHeight);
                sunLight.intensity = dayIntensity * 1.5;
                moonLight.intensity = 0.1;
                ambientLight.intensity = 0.3;
                
                if (totalHours < 8 || totalHours > 16) {
                    sunLight.color.setHex(0xffa500); 
                    ambientLight.color.setHex(0x4a4a6a);
                } else {
                    sunLight.color.setHex(0xffffff); 
                    ambientLight.color.setHex(0x404040);
                }
            } else {
                sunLight.intensity = 0.1;
                moonLight.intensity = 0.4;
                ambientLight.intensity = 0.15;
                ambientLight.color.setHex(0x2a2a4a);
            }
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            if (earth) {
                updateDayNightLighting();
                
                earth.rotation.x += (targetRotationX - earth.rotation.x) * 0.05;
                
                const baseRotation = getTimezoneRotation();
                earth.rotation.y = baseRotation + (targetRotationY * 0.3);
                
                flashlight.position.copy(camera.position);
                
                const raycaster = new THREE.Raycaster();
                const mouse = new THREE.Vector2(mouseX * 0.5, -mouseY * 0.5);
                raycaster.setFromCamera(mouse, camera);
                
                if (earth) {
                    const intersects = raycaster.intersectObject(earth);
                    if (intersects.length > 0) {
                        const intersectionPoint = intersects[0].point;
                        
                        surfaceHighlight.position.copy(intersectionPoint);
                        surfaceHighlight.lookAt(camera.position);
                        surfaceHighlight.visible = true;
                        
                        flashlight.target.position.copy(intersectionPoint);
                        
                        const time = Date.now() * 0.005;
                        surfaceHighlight.material.opacity = 0.3 + Math.sin(time) * 0.1;
                        surfaceHighlight.rotation.z += 0.02;
                    } else {
                        surfaceHighlight.visible = false;
                    }
                }
                
                const now = new Date();
                const timeString = now.toLocaleTimeString();
                const timezoneString = Intl.DateTimeFormat().resolvedOptions().timeZone;
                const hours = now.getHours();
                const dayNightIcon = (hours >= 6 && hours <= 18) ? '‚òÄÔ∏è' : 'üåô';
                
                document.getElementById('timeDisplay').innerHTML = 
                    `${dayNightIcon} ${timeString}<br>üìç ${timezoneString}`;
                
                if (userMarker) {
                    const time = Date.now() * 0.003;
                    const fastTime = Date.now() * 0.008;
                    
                    userMarker.children[1].material.opacity = 0.4 + Math.sin(time) * 0.2;
                    userMarker.children[2].material.opacity = 0.2 + Math.sin(time * 0.8) * 0.1;
                    userMarker.children[3].material.opacity = 0.6 + Math.sin(fastTime) * 0.3;
                    
                    userMarker.children[1].scale.setScalar(1 + Math.sin(time * 1.5) * 0.15);
                    userMarker.children[2].scale.setScalar(1 + Math.sin(time * 1.2) * 0.1);
                    userMarker.children[3].scale.setScalar(1 + Math.sin(fastTime * 2) * 0.2);
                    
                    userMarker.children[3].rotation.z += 0.02;
                }
            }
            
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        function createStars() {
            const starsGeometry = new THREE.BufferGeometry();
            const starsMaterial = new THREE.PointsMaterial({ 
                color: 0xffffff, 
                size: 1,
                transparent: true,
                opacity: 0.8
            });

            const starsVertices = [];
            for (let i = 0; i < 1000; i++) {
                const x = (Math.random() - 0.5) * 2000;
                const y = (Math.random() - 0.5) * 2000;
                const z = (Math.random() - 0.5) * 2000;
                starsVertices.push(x, y, z);
            }

            starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starsVertices, 3));
            const stars = new THREE.Points(starsGeometry, starsMaterial);
            scene.add(stars);
        }
        createStars();
    </script>
</body>
</html>
